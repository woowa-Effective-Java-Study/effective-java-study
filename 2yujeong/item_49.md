# 매개변수 유효성 검사

## 오류는 가능한 빨리 잡아야 한다.
매개변수 유효성 검증을 통해 잘못된 매개변수 값으로 인한 에러는 사전에 방지하는 게 좋다.
1. 매개변수와 관련된 제약의 문서화
2. 메소드 몸체 실행 전 매개변수 확인
<br>

## 매개변수 검사가 제대로 이루어지지 않을 때 발생할 수 있는 문제점
1. 메소드 수행 도중 모호한 예외 발생(메소드 실패)
2. 메소드는 문제없이 수행되지만 잘못된 결과 반환
3. 어떠한 객체를 이상한 상태로 변경(메소드 수행과는 상관 없이 추후에 이 객체와 관련된 에러 발생)
<br>

## 매개변수 관련 예외의 문서화
public과 protected 메소드는 매개변수 값이 잘못됐을 때 던지는 예외를 문서화해야 한다. 이때 해당 매개변수 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.

### 코드 예시(BigInteger의 mod 메소드)
```java
/**
 * (현재 값 mod m) 값을 반환한다. 이 메서드는
 * 항상 음이 아닌 BigInteger를 반환한다는 점에서 remainder 메서드와 다르다.
 * @param m 계수(양수여야 한다)
 * @return 현재 값 mod m
 * @throws ArithmeticException m이 0보다 작거나 같으면 발생한다.
 */
public BigInteger mod(BigInteger m) {
    if (m.signum() <= 0) {
        throw new ArithmeticException("계수(m)는 양수여야 합니다. " + m);
    }
    ... // 계산 수행
}
```
- m이 null일 경우 m.signum() 호출 시 NullPointerException 예외 발생
  - null 관련 예외는 개별 메소드가 아닌 BigInteger 클래스 레벨에서 기술 -> 문서화가 되어있지만 mod 메소드만 보고 null 관련 예외는 알 수 없다.
  - 해결 : java.util.Objects.requireNonNull 메소드
    - m.signum() 호출 전 null관련 예외를 잡을 수 있다.
    - null 검사가 이루어진다는 사실을 명시적으로 알 수 있다.'
  - 검증 관련 메소드를 잘 활용하면 예외를 명시적으로 기재할 수 있으며 더 편리한 검증이 가능하다.
<br>

## 단언문(assert)을 사용한 매개변수 유효성 검증
공개되지 않은 private 메소드라면 단언문을 활용하여 유효한 값만이 메소드에 넘겨지리라는 것을 보증하는 게 좋다.
```java
private static void EffectiveJava(int baekaraHeight) {
    assert beakaraHeight == 165;
}
```
- boolean으로 평가되는 표현식 또는 값을 받아서 참이면 그냥 지나가고 거짓이면 `AssertionError`가 발생 -> 단언문은 주어진 조건 값이 무조건 참일 것이라고 선언하는 것이다.
- 단언문은 런타임에 아무런 효과도, 성능 저하도 발생시키지 않는다.
<br>

## 그 외 매개변수 검증이 필요한 경우
1. 메소드가 직접 사용하지는 않으나 메소드 호출자로부터 나중에 사용될 데이터를 반환하는 경우
    - ex) 배열을 매개변수로 받아 List로 변환하여 반환하는 메소드
        - 입력 받은 매개변수가 null인 경우, null 검사를 수행하지 않고 그냥 List로 반환해 버리면 클라이언트가 반환 받은 List를 사용하려는 시점이 되어서야 NullPointerException이 발생한다.
        - Objects.requireNonNull을 이용해 미리 null 검사를 수행해주는 게 좋다.
2. 생성자 매개변수의 유효성 검사
    - 클래스 불변식을 어기는 객체가 만들어지지 않게 하기 위해 꼭 필요하다.
<br>

## 매개변수 유효성 검사가 필요치 않은 예외적인 경우
- 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때
- 계산 과정에서 암묵적으로 검사가 수행될 때
    - ex) Collections.sort(List)
        - 정렬 과정에서 리스트 내 원소들의 상호 비교가 이루어지며 그 과정에서 서로 비교할 수 없는 타입의 원소들이면 예외가 발생한다. 
        - 정렬 수행 전 리스트 내의 모든 원소들이 서로 비교가 가능한지 미리 검사해봐야 별 다른 실익이 없다.
