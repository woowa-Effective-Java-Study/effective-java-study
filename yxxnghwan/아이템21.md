# 아이템21 인터페이스는 구현하는 쪽을 생각해서 설계하라

자바8 이전에는 인터페이스에 메서드를 추가할 것을 전혀 고려하지 않았다.

자바8에 람다와 스트림이 추가되면서 기존 컬렉션 인터페이스에 많은 메서드들이 추가되었는데,

인터페이스에 메서드를 추가하면 구현체에서 해당 메서드를 구현하지 않아서 오류가 발생하기 때문에 `디폴트 메서드`가 추가되었다.


## 디폴트 메서드는 컴파일에 성공하더라도 기존 구현체에 런타임 오류를 일으킬 수 있다.
디폴트 메서드는 정말 하위 구현체에 영향을 주지 않을까?

자바 8의 `Collection` 인터페이스에 추가된 `removeIf` 메서드를 예시로 들어보자

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

파라미터로 `Predicate`를 받아서 조건에 맞는 모든 원소를 삭제하는 메서드이다.
자바 라이브러리의 코드 품질은 높은 편이라 해당 메서드는 대부분 상황에서는 잘 작동한다.
하지만 **생각할 수 있는 모든 불변식을 해치지 않는 디폴트 메서드를 추가하기는 어렵다.**

아파치 라이브러리중 `SynchronizedCollection<E>` 클래스는 자바의 `Collection`을 구현하는 구현체이지만,
`removeIf`를 디폴트 메서드 그대로 제공 받아 문제를 일으켰었다. (이펙티브 자바가 쓰여질 당시에는. 현재는 `SynchronizedCollection<E>`에서 `removeIf`를 재정의하고 있음.)

`SynchronizedCollection<E>`는 클라이언트가 제공한 객체로 락을 걸어서 동기화하여 멀티 스레드 환경에서 안전하게 접근할 수 있도록 구현된 구현체인데, `Collection`에게 디폴트로 물려받은 `removeIf`는 동기화에 대해 전혀 모르므로 락 객체를 사용할 수 없기 때문에 멀티 스레드 환경에서 `removeIf`를 호출하면 `ConcurrentModificationException`이 발생하거나, 예기치 못한 결과를 초래할 수 있었다.

---

디폴트 메서드는 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이지만, 디폴트 메서드로 새 메서드를 추가하는 것은 꼭 필요한 경우에만 추가하려는 디폴트 메서드가 기존 구현체들과 충돌하지는 않을 지 고려하며 추가해야한다.

인터페이스를 수정한다면, 이를 포함한 API에 어떤 재앙을 몰고 올지 알 수가 없다.
그래서 수정 이후에는 반드시 엄격한 테스트를 거쳐야 한다. (여러 테스트용 구현체와 그 것을 사용해보는 클라이언트를 테스트로 구현해보기)

### 결론
인터페이스는 처음부터 주의 기울여서 설계하고, 최대한 수정을 피하자.